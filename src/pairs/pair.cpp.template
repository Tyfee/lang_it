#include "../lang_it.h"

#if defined(ALL)
#define FROM_TO
#endif

#ifdef FROM_TO

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cstring>

using namespace std;


DICT(fixed_ngrams, {
 {"two_words", "duas palavras"}
});

DICT(adj, {
 {"blue", "azul"}
});

DICT(nouns, {
 {"cachorro", "dog"}
});

DICT(pro, {
 {"he", "ele"}
});




//normalization
//this will turn sets of letters that shift on translation and change them accordingly.
// stuff such as aceitar -> aceipt -> accept
static string normalize(string word) {
    string normalized_ = word;

    if (word.length() > 3) {

    }



    return normalized_;
}

static std::vector<Word> reorder_helpers(const std::vector<Word>& copy) {
    std::vector<Word> sentence_arr = copy;
    vector<Word> reordered_arr;

    int word_count = sentence_arr.size();





    for (size_t i = 0; i < sentence_arr.size(); ++i) {
        bool one_ = (i > 0);
        bool two_ = (i >= 1);
        bool three_ = (i >= 2);

        const Word& current = sentence_arr.at(i);
        const Word* previous = two_ ? &sentence_arr.at(i - 1) : nullptr;
        const Word* previous_ = three_ ? &sentence_arr.at(i - 2) : nullptr;



    }
}

static Word nounLookup(const std::string& word) {
    string translation;
    int word_type = -1;

    // for each individual word loop, you look in the noun dictionary
   
    LOOKUP(nouns, NOUN, word.c_str());
    LOOKUP(adj, ADJECTIVE, word.c_str());
    LOOKUP(pro, PRONOUN, word.c_str());
    LOOKUP(part, PARTICLE, word.c_str());

    return { word, normalize(translation), word_type };
}


std::string translate_code(const char* sentence) {
    char buffer[250];
    strncpy(buffer, sentence, sizeof(buffer));
    buffer[sizeof(buffer) - 1] = '\0';
    to_lower(buffer);
    vector<string> arr = tokenize(string(buffer));
    std::string translated = trigramLookup(fixed_ngrams, arr, reorder_helpers, nounLookup);

    return translated;
}

#endif